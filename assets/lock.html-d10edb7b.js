import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o,c,b as a,d as n,e,a as i}from"./app-2bc3c870.js";const l="/blog/assets/1711526206795-154d403b.png",r={},u={href:"https://zhuanlan.zhihu.com/p/71156910",target:"_blank",rel:"noopener noreferrer"},d={href:"https://tech.meituan.com/2018/11/15/java-lock.html",target:"_blank",rel:"noopener noreferrer"},k=i(`<h2 id="_0-java中的两种锁" tabindex="-1"><a class="header-anchor" href="#_0-java中的两种锁" aria-hidden="true">#</a> 0.Java中的两种锁</h2><ul><li>synchronized，关键字，在jvm中实现</li><li>Lock，一个接口</li></ul><h3 id="_0-1-synchronized" tabindex="-1"><a class="header-anchor" href="#_0-1-synchronized" aria-hidden="true">#</a> 0.1 synchronized</h3><p>synchronized是Java中的一个关键字</p><p>它是一个悲观锁，它涉及了一些锁升级的概念。</p><ul><li>在最开始时，synchronized是偏向锁，即它更加偏向于第一个获取到这个锁的线程。如果说下一次执行到同步语句，发现还是这个线程，那么synchronized就不需要重新加锁了，这样只有一个线程的话，就不需要频繁加锁，性能开销基本没有。</li><li>如果某时刻又来了一个线程，那么此时的偏向锁就会升级为轻量锁。轻量级锁是一个自旋锁，如果现在有两个线程A和B，那么A在执行的时候，B此时会自旋等待，即不会暂停执行。这个自旋等待次数是有上限的，一旦到达了某个上限，就会升级为重量级锁，此时没有争夺到锁的线程就会暂停执行，让出CPU，直到通知它再次执行。</li></ul><h3 id="_0-2-reentrantlock" tabindex="-1"><a class="header-anchor" href="#_0-2-reentrantlock" aria-hidden="true">#</a> 0.2 ReentrantLock</h3><p>ReentrantLock是可重入锁，默认是非公平锁。</p><p>这里主要说一下它是如何可重入的。</p><p>ReentrantLock里面有个内部类Sync和它的两个子类FairSync和NonFairSync，对应着公平锁和非公平锁的实现。</p><p>如何实现可重入的，我们看Sync#tryLock()：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果state值为0，表示这个锁没有被任何线程占用，通过CAS将state改为1</span>
    <span class="token comment">//（因为可能有多个线程同时争夺）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token comment">//如果争夺成功，那么把这个锁的拥有者设置为当前线程</span>
	    <span class="token comment">//这样可以保证下次重入</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//如果发现state不为1，且拥有者是本线程，表示重入 </span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>c <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>
	    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到重入的关键就是AQS中维护了state变量和所有者线程值。每重入一层，state就会加1</p><p><img src="`+l+'" alt="1711526206795"></p><h3 id="_0-3-synchronized和reentrantlock区别" tabindex="-1"><a class="header-anchor" href="#_0-3-synchronized和reentrantlock区别" aria-hidden="true">#</a> 0.3 synchronized和ReentrantLock区别</h3><ul><li>s可以修饰代码块、方法，R只可修饰方法</li><li>s是JVM层面实现的，R是实现了Lock接口，在Java层面实现的</li><li>s是非公平锁，R是默认非公平锁，可选公平锁</li><li>s是通过JVM中监视器来实现加锁解锁，R是通过AQS</li></ul><h2 id="_1-乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#_1-乐观锁和悲观锁" aria-hidden="true">#</a> 1.乐观锁和悲观锁</h2><p>对于乐观锁来说，它会认为每次读取都不会有其他线程去修改，就直接读就可以了。对于写的时候，它会比较当前值是否是期待值，如果是，则表明可能没有其他线程修改，就进行修改，否则则循环等待下次修改。</p><p>对于悲观锁来说，它认为每次读取都会有人修改，所以就在读取之前都加锁。这样在竞争激烈的情况下可能导致性能下降。</p><p>乐观锁更加适合读多写少的情况，而悲观锁更适合写多的情况</p><h3 id="_1-1-乐观锁有什么问题" tabindex="-1"><a class="header-anchor" href="#_1-1-乐观锁有什么问题" aria-hidden="true">#</a> 1.1 乐观锁有什么问题？</h3><p>乐观锁一般使用CAS来实现。</p><p>使用CAS时，可能会有三个问题：</p><ul><li>可能会导致ABA问题，即其他线程把数据从A修改到B，又从B修改到A，这时我们的线程是发现不了数据变化的</li><li>在写多的场景下，CAS会频繁失败然后循环等待，这时也是比较耗时的。</li><li>CAS只能保证单个共享变量的原子性，没办法保证多个共享变量的原子性</li></ul><h3 id="_1-2-java中哪些实现是悲观锁-哪些是乐观锁" tabindex="-1"><a class="header-anchor" href="#_1-2-java中哪些实现是悲观锁-哪些是乐观锁" aria-hidden="true">#</a> 1.2 Java中哪些实现是悲观锁，哪些是乐观锁</h3><p>Java中，无论是synchronized还是Lock接口，都是悲观锁。</p><p>Java中乐观锁可以使用Unsafe的CAS，还有一些原子类都是乐观锁</p><h2 id="_2-自旋锁" tabindex="-1"><a class="header-anchor" href="#_2-自旋锁" aria-hidden="true">#</a> 2.自旋锁</h2><p>自旋锁就是一个线程在CPU执行时，发现同步资源是上锁的，此时不必让出CPU，而是在CPU中自旋等待，等待到同步资源解锁直接开始执行就可以了。</p><p>因为自旋锁不会让出CPU，等待线程会在CPU中无用的自旋操作，所以会有一定的上限，如果自旋次数超过某个数量，就不再自旋了。</p><p>此外，后面还引入了自适应自旋锁，即自旋次数不再固定，而是根据历史的自旋次数等因素来动态决定。</p><h2 id="_3-公平锁和非公平锁" tabindex="-1"><a class="header-anchor" href="#_3-公平锁和非公平锁" aria-hidden="true">#</a> 3.公平锁和非公平锁</h2><ul><li>公平锁：按照线程队列的顺序来获取锁，只有队头的线程才可以获得锁</li><li>非公平锁：队列中的线程都可以竞争锁，会出现后来的线程却先得到锁的情况，也可以不进队列直接执行。<strong>非公平锁可以提高性能，因为有时候线程不必经历暂停-恢复的过程</strong>，但是可能出现线程饿死的情况。</li></ul><p><strong>公平锁就是线程直接进入阻塞队列，直到成为队列的第一个，才可以获得锁。非公平锁就是多个线程加锁时直接尝试上锁，上锁成功直接执行，失败进入阻塞队列。</strong></p><p>ReentrantLock默认的实现就是非公平锁。<strong>它其中有一个Sync类，继承了AQS</strong>，它有两个子类FairSync和NonfairSync，对应着公平锁和非公平锁。</p><h2 id="_4-可重入锁-非可重入锁" tabindex="-1"><a class="header-anchor" href="#_4-可重入锁-非可重入锁" aria-hidden="true">#</a> 4.可重入锁，非可重入锁</h2><p><strong>可重入锁又叫递归锁，就是如果一个线程在外部方法已经获取了锁，那么在进入内部方法时，会自动获得锁，而不会被阻塞</strong>。</p><p>可重入锁可以防止死锁。</p><p>synchronized和ReentrantLock都是可重入锁。</p><h2 id="_5-共享锁和排他锁" tabindex="-1"><a class="header-anchor" href="#_5-共享锁和排他锁" aria-hidden="true">#</a> 5.共享锁和排他锁</h2><p>共享锁就是多个线程可同时持有一把锁，排他锁就是同时只可有一个线程获得一把锁。</p><p><strong>某个同步资源加了共享锁，那么其他线程也只能加共享锁，不能加排他锁，而且共享锁只能读数据，不能写数据。</strong></p>',42);function h(v,m){const s=p("ExternalLinkIcon");return o(),c("div",null,[a("p",null,[n("总结于"),a("a",u,[n("文章1"),e(s)]),n(),a("a",d,[n("文章2"),e(s)])]),k])}const f=t(r,[["render",h],["__file","lock.html.vue"]]);export{f as default};
