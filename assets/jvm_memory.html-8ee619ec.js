import{_ as h}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as t,c as d,b as e,d as a,e as i,a as l}from"./app-2bc3c870.js";const o="/blog/assets/1711079277191-7d354805.png",s="/blog/assets/1711080143073-38fba1b0.png",c={},p={href:"https://zhuanlan.zhihu.com/p/38348646",target:"_blank",rel:"noopener noreferrer"},_={href:"https://cloud.tencent.com/developer/article/2398564",target:"_blank",rel:"noopener noreferrer"},m=l('<h2 id="_1-jvm内存结构-也叫jvm内存模型" tabindex="-1"><a class="header-anchor" href="#_1-jvm内存结构-也叫jvm内存模型" aria-hidden="true">#</a> 1.JVM内存结构（也叫JVM内存模型）</h2><p>JVM内存结构包括</p><ul><li>堆</li><li>方法区</li><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数器</li></ul><h3 id="想额外强调关于常量池的事情" tabindex="-1"><a class="header-anchor" href="#想额外强调关于常量池的事情" aria-hidden="true">#</a> 想额外强调关于常量池的事情：</h3><ul><li>JDK 1.7之前，常量池在方法区（当时方法区的实现方法是永久代）中</li><li>JDK 1.7，字符串常量池单独从方法区移到堆中，其他常量还在方法区中</li><li>JDK 1.8，方法区的实现方式由永久代改为元空间，所以字符串常量池在堆中，其他常量在元空间中</li></ul><h3 id="_1-1-堆" tabindex="-1"><a class="header-anchor" href="#_1-1-堆" aria-hidden="true">#</a> 1.1 堆</h3><p><img src="'+o+'" alt="1711079277191"></p><p>堆是线程共享的，是引用类型的存放位置，也是垃圾回收的主要区域</p><p>堆中可以分为新生代和老年代</p><h3 id="_1-2-方法区" tabindex="-1"><a class="header-anchor" href="#_1-2-方法区" aria-hidden="true">#</a> 1.2 方法区</h3><p>方法区也是线程共享的，它会存放一些类的静态变量和类的信息（即类模型对象）</p><h3 id="_1-3-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#_1-3-虚拟机栈" aria-hidden="true">#</a> 1.3 虚拟机栈</h3><p>虚拟机栈是线程私有的，虚拟机栈是存放方法执行中的基本类型和引用类型的引用的位置</p><h3 id="_1-4-本地方法栈" tabindex="-1"><a class="header-anchor" href="#_1-4-本地方法栈" aria-hidden="true">#</a> 1.4 本地方法栈</h3><p>本地方法栈也是线程私有的，是Java调用native原生方法执行C/C++方法的位置</p><h3 id="_1-5-程序计数器" tabindex="-1"><a class="header-anchor" href="#_1-5-程序计数器" aria-hidden="true">#</a> 1.5 程序计数器</h3><p>程序计数器也是线程私有的，它记录了虚拟机执行到了哪行字节码</p><h2 id="_2-java内存模型jmm" tabindex="-1"><a class="header-anchor" href="#_2-java内存模型jmm" aria-hidden="true">#</a> 2.Java内存模型JMM</h2><p>Java内存模型是给Java多线程通信准备的，整体上围绕了</p><ul><li>可见性</li><li>有序性</li><li>原子性</li></ul><p>三大特性展开</p><h3 id="_2-1-可见性" tabindex="-1"><a class="header-anchor" href="#_2-1-可见性" aria-hidden="true">#</a> 2.1 可见性</h3><p>所谓可见性，就是一个线程对某个变量进行操作，其他线程是可以看见的。我们可以使用volatile关键字或者synchronized代码段来保证可见性。</p><h3 id="_2-2-有序性" tabindex="-1"><a class="header-anchor" href="#_2-2-有序性" aria-hidden="true">#</a> 2.2 有序性</h3><p>为了优化性能，JVM会进行指令重排，比如写操作可能会放到最后执行。但是对于多线程来说，指令重排可能会导致一些问题，比如一个线程的读在另一个线程的写之后，为了解决这一问题，JVM引入了happens-before原则，保证了多线程操作的有序性</p><h3 id="_2-3-原子性" tabindex="-1"><a class="header-anchor" href="#_2-3-原子性" aria-hidden="true">#</a> 2.3 原子性</h3><p>原子性是指某一个操作是原子的，不会被其他线程打断。Java中使用volatile关键字标记的变量读写就不会被其他线程打断。</p><h3 id="_2-4-工作内存和主内存" tabindex="-1"><a class="header-anchor" href="#_2-4-工作内存和主内存" aria-hidden="true">#</a> 2.4 工作内存和主内存</h3><p>主内存是线程共有的，其中保存着一些变量。</p><p>工作内存是线程私有的，是JVM虚拟出来的一块内存，它之中保存着主内存中变量的副本。</p><p>一个线程对主内存的变量进行写入，先通过工作内存，然后再写入主内存。然后，另一个线程会从主内存中读取这个变量到自己的工作内存中，从而得知变化。</p><p><img src="'+s+'" alt="1711080143073"></p>',32);function u(f,b){const r=n("ExternalLinkIcon");return t(),d("div",null,[e("p",null,[a("参考"),e("a",p,[a("参考1"),i(r)]),a(),e("a",_,[a("参考2"),i(r)])]),m])}const J=h(c,[["render",u],["__file","jvm_memory.html.vue"]]);export{J as default};
