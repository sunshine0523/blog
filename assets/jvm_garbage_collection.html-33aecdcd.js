const l=JSON.parse('{"key":"v-a8c61842","path":"/java/jvm_garbage_collection.html","title":"3、JVM垃圾回收","lang":"zh-CN","frontmatter":{"title":"3、JVM垃圾回收"},"headers":[{"level":2,"title":"1.堆内存结构","slug":"_1-堆内存结构","link":"#_1-堆内存结构","children":[]},{"level":2,"title":"2.内存分配和回收原则","slug":"_2-内存分配和回收原则","link":"#_2-内存分配和回收原则","children":[{"level":3,"title":"2.1 分配原则","slug":"_2-1-分配原则","link":"#_2-1-分配原则","children":[{"level":4,"title":"新的对象优先分配到新生代的伊甸园","slug":"新的对象优先分配到新生代的伊甸园","link":"#新的对象优先分配到新生代的伊甸园","children":[]},{"level":4,"title":"大内存对象会被分配到老年代","slug":"大内存对象会被分配到老年代","link":"#大内存对象会被分配到老年代","children":[]},{"level":4,"title":"长期存活的对象将会进入老年代","slug":"长期存活的对象将会进入老年代","link":"#长期存活的对象将会进入老年代","children":[]}]},{"level":3,"title":"GC分类","slug":"gc分类","link":"#gc分类","children":[]},{"level":3,"title":"空间分配担保","slug":"空间分配担保","link":"#空间分配担保","children":[]}]},{"level":2,"title":"2. 死亡对象的判断方法","slug":"_2-死亡对象的判断方法","link":"#_2-死亡对象的判断方法","children":[{"level":3,"title":"2.1 引用计数器","slug":"_2-1-引用计数器","link":"#_2-1-引用计数器","children":[]},{"level":3,"title":"2.2 可达性分析","slug":"_2-2-可达性分析","link":"#_2-2-可达性分析","children":[{"level":4,"title":"哪些对象可以作为GC Roots","slug":"哪些对象可以作为gc-roots","link":"#哪些对象可以作为gc-roots","children":[]},{"level":4,"title":"不可达的对象一定会被垃圾回收吗","slug":"不可达的对象一定会被垃圾回收吗","link":"#不可达的对象一定会被垃圾回收吗","children":[]}]},{"level":3,"title":"2.3 如何判断一个常量可以被回收","slug":"_2-3-如何判断一个常量可以被回收","link":"#_2-3-如何判断一个常量可以被回收","children":[]},{"level":3,"title":"2.4 如何判断一个类可以进行回收","slug":"_2-4-如何判断一个类可以进行回收","link":"#_2-4-如何判断一个类可以进行回收","children":[]}]},{"level":2,"title":"3.引用类型总结","slug":"_3-引用类型总结","link":"#_3-引用类型总结","children":[{"level":3,"title":"3.1 强引用","slug":"_3-1-强引用","link":"#_3-1-强引用","children":[]},{"level":3,"title":"3.2 软引用","slug":"_3-2-软引用","link":"#_3-2-软引用","children":[]},{"level":3,"title":"3.3 弱引用","slug":"_3-3-弱引用","link":"#_3-3-弱引用","children":[{"level":4,"title":"弱引用的应用","slug":"弱引用的应用","link":"#弱引用的应用","children":[]}]},{"level":3,"title":"3.4 虚引用","slug":"_3-4-虚引用","link":"#_3-4-虚引用","children":[]}]},{"level":2,"title":"4.垃圾收集算法","slug":"_4-垃圾收集算法","link":"#_4-垃圾收集算法","children":[{"level":3,"title":"4.1 标记-清除","slug":"_4-1-标记-清除","link":"#_4-1-标记-清除","children":[]},{"level":3,"title":"4.2 标记-复制","slug":"_4-2-标记-复制","link":"#_4-2-标记-复制","children":[]},{"level":3,"title":"4.3 标记-整理","slug":"_4-3-标记-整理","link":"#_4-3-标记-整理","children":[]},{"level":3,"title":"4.4 分代收集","slug":"_4-4-分代收集","link":"#_4-4-分代收集","children":[]}]},{"level":2,"title":"5.垃圾收集器","slug":"_5-垃圾收集器","link":"#_5-垃圾收集器","children":[{"level":3,"title":"5.1 Serial 串行","slug":"_5-1-serial-串行","link":"#_5-1-serial-串行","children":[]},{"level":3,"title":"5.2 ParNew","slug":"_5-2-parnew","link":"#_5-2-parnew","children":[]},{"level":3,"title":"5.3 Parallel Scavenge","slug":"_5-3-parallel-scavenge","link":"#_5-3-parallel-scavenge","children":[]},{"level":3,"title":"5.4 CMS Concurrent Mark Sweep","slug":"_5-4-cms-concurrent-mark-sweep","link":"#_5-4-cms-concurrent-mark-sweep","children":[]},{"level":3,"title":"5.5 G1","slug":"_5-5-g1","link":"#_5-5-g1","children":[]},{"level":3,"title":"5.6 ZGC","slug":"_5-6-zgc","link":"#_5-6-zgc","children":[]}]}],"git":{"createdTime":1711351828000,"updatedTime":1711351828000,"contributors":[{"name":"KindBrave","email":"1773747161@qq.com","commits":1}]},"readingTime":{"minutes":9.07,"words":2721},"filePathRelative":"java/jvm_garbage_collection.md","localizedDate":"2024年3月25日","excerpt":""}');export{l as data};
