import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as l,c as i,a as r}from"./app-2bc3c870.js";const a={},o=r('<h2 id="_1-什么是线程池-优点" tabindex="-1"><a class="header-anchor" href="#_1-什么是线程池-优点" aria-hidden="true">#</a> 1.什么是线程池/优点</h2><p>线程池就是利用池化技术来管理线程。使用线程池的优点：</p><ul><li>降低资源消耗。线程池可以规定线程数量，并且可以复用线程。</li><li>提高响应速度。因为线程池当中的线程是可以复用的，所以可以免去线程创建和销毁所带来的时间消耗</li><li>方便进行线程管理。线程池中的线程是可监控可管理的。</li></ul><h2 id="_2-创建线程池的方式" tabindex="-1"><a class="header-anchor" href="#_2-创建线程池的方式" aria-hidden="true">#</a> 2.创建线程池的方式</h2><ul><li>使用工厂类Executors</li><li>使用ThreadPoolExecutor</li></ul><p>⭐Executors</p><p>不推荐使用这个工厂类。因为它内部的很多线程池可能会导致OOM（比如FixedThreadPool、SingleThreadExecutor，使用无限队列，可能导致队列OOM。CachedThreadPool，使用无限线程，可能导致OOM），而且不方便进行灵活控制。</p><p>Executors中的线程池介绍：</p><ul><li>FixedThreadPool。它的核心线程数量和最大线程数量相同，阻塞队列使用LinkedBlockingQueue，<strong>即阻塞队列无限大</strong>，可能导致OOM</li><li>SingleThreadExecutor。核心线程数和最大线程数都是1，阻塞队列同上，可能导致OOM</li><li>CachedThreadPool。核心线程数为0，<strong>最大线程数为无限大</strong>，阻塞队列为SynchronousQueue同步队列，即阻塞队列不可存放作业，可能导致OOM</li><li>ScheduledThreadPool。核心线程数自定，<strong>最大线程数为无限大</strong>，阻塞队列为DelayedWorkQueue延时队列（这个延时是指任务延时），可能导致OOM。</li></ul><p>因为它们都会导致OOM，所以不推荐。</p><p>⭐ThreadPoolExecutor</p><p>推荐使用ThreadPoolExecutor来进行灵活控制线程池</p><h3 id="_2-1-构造参数" tabindex="-1"><a class="header-anchor" href="#_2-1-构造参数" aria-hidden="true">#</a> 2.1 构造参数</h3><p>ThreadPoolExecutor的构造参数有哪些？</p><ul><li>核心线程数：线程池的核心线程数，如果当前运行的线程数量小于这个数，那么会创建新线程来执行任务</li><li>最大线程数：线程池可以运行的最大线程数</li><li>空闲线程等待时间：如果线程空闲时间超过这个时间，那么会进行销毁</li><li>时间单位：上述的时间单位</li><li>线程池饱和策略：如果线程数量达到最大，任务队列也满了，那么会执行这个策略。</li></ul><h3 id="_2-2-饱和策略" tabindex="-1"><a class="header-anchor" href="#_2-2-饱和策略" aria-hidden="true">#</a> 2.2 饱和策略</h3><ul><li><p>线程池饱和策略有哪些？</p><ul><li>拒绝。直接抛出异常</li><li>调用者执行。通过调用者所在的线程来执行。这个会让调用者所在线程执行变慢，如果不在意可以考虑。因为这个不会抛弃任何任务。</li><li>丢弃。新的任务直接丢弃，不处理</li><li>丢弃最早。把消息队列中最早的任务丢掉，放入本个任务。</li></ul></li></ul><h3 id="_2-3-阻塞队列" tabindex="-1"><a class="header-anchor" href="#_2-3-阻塞队列" aria-hidden="true">#</a> 2.3 阻塞队列</h3><ul><li>阻塞队列有哪些？ <ul><li>有限队列。ArrayBlockingQueue。该队列有界限，底层数据结构是ArrayList。</li><li>无限队列。LinkedBlockingQueue。该队列默认长度为Inteter.MAX_VALUE（可手动指定有界），可以算作无界，底层用的是LinkedList。该队列用在了SingleThreadExecutor和FixedThreadPool中。其中SingleThreadExecutor的核心线程和最大线程都是1，FixedThreadPool的核心线程和最大线程是一致的。它们的任务队列可以看作无界的。</li><li>同步队列。同步队列的空间为0，不能存放任何任务。它用在CachedThreadPool中，CachedThreadPool的最大线程数为无限。</li><li>延迟队列。延迟队列底层使用堆来实现的。延迟队列排序方式不是任务的添加顺序，而是任务的<strong>延迟时间</strong>。<strong>每次出队的任务都是当前延迟最小的任务</strong>。</li></ul></li><li>LinkedBlockingQueue和ArrayBlockingQueue的区别？ <ul><li>L默认是无界队列，默认长度是Integer.MAX_VALUE，而A在初始化的时候必须指定容量，是有界队列</li><li>锁机制不同，A没有进行锁分离，即入队和出队用的是一把ReentrantLock，而L是锁分离的，入队和出队用的是两把锁。也因此，L的并发性能会更好一些</li><li>底层实现不同，A底层是数组，L底层是链表</li></ul></li></ul><h2 id="_3-线程池处理任务细节" tabindex="-1"><a class="header-anchor" href="#_3-线程池处理任务细节" aria-hidden="true">#</a> 3. 线程池处理任务细节</h2><p>线程池处理新来的任务有以下几个步骤：</p><ul><li>如果当前线程池中运行的线程数量小于核心线程数，那么会创建新线程来执行</li><li>如果当前线程池中运行的线程数量大于等于核心线程数，但是任务队列还没有满，那么先放到任务队列中等待执行</li><li>如果任务队列也满了，那么会判断当前运行的线程数量是否大于最大线程，如果不大于，那么会继续创建线程来执行</li><li>如果当前运行的线程已经到达最大线程数量了，那么就拒绝调用饱和策略了。</li></ul><h2 id="_4-线程池是如何进行线程复用的" tabindex="-1"><a class="header-anchor" href="#_4-线程池是如何进行线程复用的" aria-hidden="true">#</a> 4. 线程池是如何进行线程复用的</h2><p>我们似乎并没有在上述线程池处理细节中发现如何进行线程复用的。实际上的奥秘在于Worker中。</p><p>我们知道，如果当前运行的线程数量不大于核心线程数，会addWorker。在大于核心线程数，会放到任务队列当中去，那么最终这个任务队列当中的任务是谁执行的呢？</p><p>没错，就是之前addWorker中的Worker。这些Worker不会在执行完一个任务后就释放掉，而是会阻塞等待任务队列中的任务，如果有任务来了，就会交给它们来执行。</p>',26),d=[o];function h(t,n){return l(),i("div",null,d)}const s=e(a,[["render",h],["__file","thread_pool.html.vue"]]);export{s as default};
