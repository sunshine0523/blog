import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as t,c,b as i,d as e,e as o,w as l,a}from"./app-2bc3c870.js";const h="/blog/assets/1711334882336-a1091e01.png",s={},p=a('<h2 id="_1-mvcc" tabindex="-1"><a class="header-anchor" href="#_1-mvcc" aria-hidden="true">#</a> 1.MVCC</h2><p>MVCC就是多版本并发控制，一般用于数据库中，比如MySQL。现在的数据库往往需要进行大量的并发操作，传统往往是通过加锁的方式实现的，但是这样可能会造成死锁或者阻塞的情况。而MVCC可以做到不上锁进行读取数据，保证多事务并发操作的的一致性和隔离性。</p><p>MVCC使用<strong>快照</strong>的方式进行读写操作。</p><h3 id="_1-1-读" tabindex="-1"><a class="header-anchor" href="#_1-1-读" aria-hidden="true">#</a> 1.1 读</h3><p>MVCC读的时候，会使用快照进行读取，即选择一个事务开始时间之前最新的快照，通过这个快照进行读取，此时其他事务可以进行写操作。</p><h3 id="_1-2-写" tabindex="-1"><a class="header-anchor" href="#_1-2-写" aria-hidden="true">#</a> 1.2 写</h3><p>MVCC在写的时候，会创建一个快照，并且把数据的修改放到快照中，然后再更新到数据库</p><h3 id="_1-3-事务的提交和回滚" tabindex="-1"><a class="header-anchor" href="#_1-3-事务的提交和回滚" aria-hidden="true">#</a> 1.3 事务的提交和回滚</h3><p>事务提交的时候，它的修改会同步到数据库当中</p><p>事务回滚的时候，它的修改会被删除</p><h3 id="_1-4-快照清除" tabindex="-1"><a class="header-anchor" href="#_1-4-快照清除" aria-hidden="true">#</a> 1.4 快照清除</h3><p>在一段时间过后，旧的快照会被清除</p><h2 id="_2-一致性非锁定读和锁定读" tabindex="-1"><a class="header-anchor" href="#_2-一致性非锁定读和锁定读" aria-hidden="true">#</a> 2.一致性非锁定读和锁定读</h2><h3 id="_2-1-一致性非锁定读" tabindex="-1"><a class="header-anchor" href="#_2-1-一致性非锁定读" aria-hidden="true">#</a> 2.1 一致性非锁定读</h3><p>一致性非锁定读就是读的时候不必等待当前数据行上的锁释放，可直接读取。一致性非锁定读的实现方式一般是多版本控制，比如MVCC。</p><p>一致性非锁定读就是<strong>快照读</strong>。</p><blockquote><p>RR隔离级别：Repeatable Read，可重复读</p><p>RC隔离级别：Read Commited，读已提交</p></blockquote>',17),_=a('<p>即使一个数据加了X锁，一致性非锁定读都可以进行读取，因为使用的是快照读</p><p>在RC和RR隔离级别，普通的select都是用一致性非锁定读，<strong>在RR隔离级别，还可以实现可重复读和防止部分幻读</strong></p><ul><li>这个部分幻读是哪一部分？在两次查询之间，如果有一个事务进行插入，RR隔离级别的MVCC就不会产生幻读，因为RR隔离模式下，MVCC只会在第一次查询创建ReadView，所以不会幻读</li><li>RC隔离级别不可以防止幻读，就是因为RC隔离级别下ReadView在每次select时都会生成一次</li></ul><h3 id="_2-2-锁定读" tabindex="-1"><a class="header-anchor" href="#_2-2-锁定读" aria-hidden="true">#</a> 2.2 锁定读</h3><p>锁定读就是在读取数据行的时候需要加锁</p><p>比如：</p><p><code>select ... lock in share mode</code>会对数据加S锁</p><p><code>select ... for update</code> <code>insert</code> <code>update</code> <code>delete</code>会对数据加X锁</p><ul><li>对于加S锁的数据，其他事务也可以加S锁，但是不能加X锁</li><li>加X锁的数据，任何锁都不能加</li></ul><p>在2.1节中我们说，RR隔离级别的MVCC可以防止部分幻读，但是锁定读因为是当前读，所以可能会有幻读问题，~解决办法是对读的数据加一个Next key lock，防止两次查询之间插入。~ 解决办法就是对这张表加next key lock。</p>',10),u=a('<h3 id="_2-3-总结-innodb如何解决幻读问题" tabindex="-1"><a class="header-anchor" href="#_2-3-总结-innodb如何解决幻读问题" aria-hidden="true">#</a> 2.3 总结：InnoDB如何解决幻读问题？</h3><p>InnoDB在RR隔离模式下，使用MVCC + Next key lock来解决幻读问题</p><ul><li>使用 <code>select</code>读时，会使用MVCC来进行一致性非锁定读，此时不会产生幻读</li><li>使用 <code>select lock in share model</code>、<code>select for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>时，会使用锁定读，此时可能会产生幻读，所以使用next key lock来解决幻读问题。</li></ul><p>综上来防止幻读问题</p><h2 id="_3-innodb对mvcc的实现" tabindex="-1"><a class="header-anchor" href="#_3-innodb对mvcc的实现" aria-hidden="true">#</a> 3.InnoDB对MVCC的实现</h2><p>InnoDB中使用以下内容来实现MVCC：</p><ul><li>隐藏字段</li><li>ReadView</li><li>undo log</li></ul><h3 id="_3-1-隐藏字段" tabindex="-1"><a class="header-anchor" href="#_3-1-隐藏字段" aria-hidden="true">#</a> 3.1 隐藏字段</h3><p>InnoDB会对每个数据行增加三个隐藏字段：</p><ul><li>行号</li><li>事务号：用来记录最后对该行进行操作的是哪个事务</li><li>回滚id：用于数据回滚和MVCC找到上一个更新</li></ul><h3 id="_3-2-readview" tabindex="-1"><a class="header-anchor" href="#_3-2-readview" aria-hidden="true">#</a> 3.2 ReadView</h3><p>ReadView<strong>用来做可见性判断的</strong>。</p><p>它其中保存着</p><ul><li>创建这个ReadView的事务id</li><li>这个ReadView可见的事务id上限</li><li>这个ReadView不可见的事务id下限</li></ul><p>等信息</p><h3 id="_3-3-undo-log" tabindex="-1"><a class="header-anchor" href="#_3-3-undo-log" aria-hidden="true">#</a> 3.3 undo log</h3><p>undo log用来对数据进行回滚和MVCC找到上一个修改的内容</p><h3 id="_3-4-数据可见性" tabindex="-1"><a class="header-anchor" href="#_3-4-数据可见性" aria-hidden="true">#</a> 3.4 数据可见性</h3><p>上面我们介绍ReadView中存放了对当前事务来说可见事务的上限和不可见事务的下限</p><ul><li>对于可见事务的上限之下的事务，对该事务来说都是可见的</li><li>对于不可见事务的下限之上的事务，对于该事务都是不可见的</li><li>对于两者之间的事务，要考虑这个事务是否活跃，如果活跃则不可见，不活跃就是可见的</li></ul><p><img src="'+h+'" alt="1711334882336"></p>',21);function C(R,V){const d=n("RouterLink");return t(),c("div",null,[p,i("p",null,[e("有关更详细的数据库隔离级别，请见"),o(d,{to:"/mysql/transaction_isolation_level.html"},{default:l(()=>[e("这篇文章")]),_:1}),e("。")]),_,i("p",null,[e("可以看一下 "),o(d,{to:"/mysql/transaction_isolation_level.html"},{default:l(()=>[e("这个")]),_:1}),e("。")]),u])}const b=r(s,[["render",C],["__file","mvcc.html.vue"]]);export{b as default};
