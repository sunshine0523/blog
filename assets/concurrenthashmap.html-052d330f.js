import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o,c as h,b as e,d as a,e as t,w as s,a as c}from"./app-2bc3c870.js";const u={},d={href:"https://zhuanlan.zhihu.com/p/268614609",target:"_blank",rel:"noopener noreferrer"},p=e("p",null,"ConcurrentHashMap的底层实现和HashMap差不多，都是Node节点数组+链表/红黑树",-1),_=e("p",null,"底层区别就是红黑树的实现部分了。",-1),C=e("p",null,"HashMap的红黑树实现是TreeNode，TreeNode负责红黑树的插入、删除、查找等功能",-1),m=e("p",null,"而ConcurrentHashMap为了实现粒度更小的加锁，使用TreeBin来作为一个加锁粒度，它也负责红黑树的插入、删除、查找等操作，而TreeNode只负责红黑树的查找操作。TreeBin不保存实际的数据，而是维护红黑树的根。实际上的数据还是TreeNode存储的。",-1),b=e("h2",{id:"_1-concurrenthashmap如何保证线程安全的",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-concurrenthashmap如何保证线程安全的","aria-hidden":"true"},"#"),a(" 1. ConcurrentHashMap如何保证线程安全的")],-1),f=e("p",null,"ConcurrentHashMap主要通过CAS和synchronized来保证线程安全",-1),H=c('<p>其实可以说的主要就是putVal方法和initTable方法。</p><h3 id="_1-1-putval" tabindex="-1"><a class="header-anchor" href="#_1-1-putval" aria-hidden="true">#</a> 1.1 putVal</h3><ul><li>putVal方法首先会判断当前表是否为空，如果为空的话，就CAS调用initTable方法来初始化表</li><li>如果不为空，先判断当前key的应该在的位置是否为空 <ul><li>如果为空，那么就CAS插入，如果CAS插入成功，就结束了。如果CAS插入失败，那么就自旋等待直到插入成功</li><li>如果当前位置不为空，那么就给当前位置首节点上锁，然后如果是链表，就在链表尾部插入，如果是红黑树，那么就调用红黑树的插入方法。当然，插入之前要先判断是否需要把链表转换为红黑树</li></ul></li></ul><h3 id="_1-2-inittable" tabindex="-1"><a class="header-anchor" href="#_1-2-inittable" aria-hidden="true">#</a> 1.2 initTable</h3><p>对于initTable来说，也是通过CAS完成线程安全的初始化的</p><ul><li>如果当前表不为空，结束</li><li>如果当前表为空， <ul><li>那么要比较一个叫sizeCtl的变量，如果该变量为-1，表示有其他线程正在插入，此时会让出线程</li><li>如果sizeCtl为0，那么就通过CAS给该变量赋值为-1，如果成功了，就初始化，如果失败了，就自旋等待</li></ul></li></ul><h2 id="_2-concurrenthashmap和hashtable" tabindex="-1"><a class="header-anchor" href="#_2-concurrenthashmap和hashtable" aria-hidden="true">#</a> 2.ConcurrentHashMap和Hashtable</h2><p>两者都能保证线程安全，但是实现方式不同，底层数据结构也不同</p><ul><li>CHM采用CAS加synchronized来保证线程安全，是对Node节点进行上锁的。而Hashtable是对整张表上锁的</li><li>CHM的底层数据结构和HashMap基本一致，除了TreeBin，也是采用Node节点加链表/红黑树来做底层数据结构的。而Hashtable就是使用节点+链表拉链法来实现的</li></ul>',9);function T(x,N){const l=n("ExternalLinkIcon"),r=n("RouterLink");return o(),h("div",null,[e("p",null,[a("参考"),e("a",d,[a("文章1"),t(l)])]),p,_,C,m,b,f,e("p",null,[a("有关CAS的内容，见"),t(r,{to:"/java/unsafe.html"},{default:s(()=>[a("Unsafe类介绍")]),_:1}),a("。")]),H])}const A=i(u,[["render",T],["__file","concurrenthashmap.html.vue"]]);export{A as default};
