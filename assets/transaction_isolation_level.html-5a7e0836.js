import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as l,c as i,b as a,d as e,e as t,a as s}from"./app-2bc3c870.js";const d={},c={href:"https://blog.csdn.net/qq_42799615/article/details/110942949",target:"_blank",rel:"noopener noreferrer"},p={href:"https://javaguide.cn/database/mysql/transaction-isolation-level.html",target:"_blank",rel:"noopener noreferrer"},h=s('<p>SQL标准制定了四个隔离级别：</p><ul><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>可串行化</li></ul><p>（这个应该如何理解？比如读未提交，就是读可以读到还没有提交的数据。读已提交就是可以读到已经提交的数据）</p><p>这四个对应解决三个问题：脏读、幻读、不可重复读</p><h2 id="_1-读未提交" tabindex="-1"><a class="header-anchor" href="#_1-读未提交" aria-hidden="true">#</a> 1.读未提交</h2><p>表示读可以读到还没有提交的数据。这会导致<strong>脏读</strong>的问题。</p><p>别的事务还没有提交的数据就被读出来了，就是脏读</p><h2 id="_2-读已提交" tabindex="-1"><a class="header-anchor" href="#_2-读已提交" aria-hidden="true">#</a> 2.读已提交</h2><p>表示读只能读到别的事务已经提交的数据。</p><p>这个级别不会发生脏读的问题，但是会导致<strong>不可重复读</strong>的问题。</p><p>因为别的事务提交了，我们的事务就会读出来，也就是同一个事务读取的结果可能不一致。</p><h2 id="_3-可重复读" tabindex="-1"><a class="header-anchor" href="#_3-可重复读" aria-hidden="true">#</a> 3.可重复读</h2><p>一个事务中读取到的数据始终是一致的，不管别的事务有没有进行修改/删除（新增不可以）。</p><p>这个级别可以保证可重复读，但是可能会产生<strong>幻读</strong>的问题。</p><h3 id="_3-1-什么是幻读" tabindex="-1"><a class="header-anchor" href="#_3-1-什么是幻读" aria-hidden="true">#</a> 3.1 什么是幻读？</h3><p><strong>简单来说，就是原本不存在的数据，现在出现了，就是幻读。</strong></p><p>幻读和可重复读的区别：可重复读是考虑一行的内容是否更改。幻读是考虑一个表中的内容是否更改。或者说，可重复读考虑的是现有的行， 幻读考虑的是新增的行。</p><h2 id="_4-可串行化" tabindex="-1"><a class="header-anchor" href="#_4-可串行化" aria-hidden="true">#</a> 4.可串行化</h2><p>可串行化是把所有事务以串行的形式来执行，这样就不会产生并发问题了。</p><h2 id="_5-mysql的隔离级别" tabindex="-1"><a class="header-anchor" href="#_5-mysql的隔离级别" aria-hidden="true">#</a> 5.MySQL的隔离级别？</h2><p>MySQL默认是可重复读RR级别，但是它却可以防止幻读。</p><h3 id="_5-1-mysql如何在rr级别下实现防止幻读的" tabindex="-1"><a class="header-anchor" href="#_5-1-mysql如何在rr级别下实现防止幻读的" aria-hidden="true">#</a> 5.1 MySQL如何在RR级别下实现防止幻读的</h3><p>MySQL使用下面两种方式防止幻读：</p><ul><li>MVCC</li><li>next key lock</li></ul><p>※ MVCC</p><p>在MySQL的InnoDB引擎下，MVCC多版本并发控制被引入了。MVCC可以让并发多事务保证一致性和隔离性。它使用快照读写方式，对每个数据行都保存多个快照，来解决一些问题。</p><p>我们在使用select进行读的时候，会使用MVCC的快照读，这样在RR隔离级别时，只会在第一次select时才会创建ReadView，这样就可以可重复读和防止幻读。</p><p>※ next key lock</p><p>对于 <code>select lock in share mode</code> <code>select for update</code> <code>insert</code> <code>update</code> <code>delete</code> 这些，会使用当前读的方式。</p><ul><li>select lock in share mode会加S锁，其他只能加S锁</li><li>其余情况会加X锁，其他什么锁都不能加</li></ul><p>但是，对行加锁只能解决可重复读问题，幻读无法保证，所以还需要给表加next key lock</p><p>next key lock是行锁+间隙锁，我们给表的间隙也上锁，这样就没有办法在两次查询之间插入了，就不会产生幻读的问题了。</p>',32);function _(u,f){const r=o("ExternalLinkIcon");return l(),i("div",null,[a("p",null,[e("总结于"),a("a",c,[e("文章1"),t(r)]),e(),a("a",p,[e("文章2"),t(r)])]),h])}const k=n(d,[["render",_],["__file","transaction_isolation_level.html.vue"]]);export{k as default};
