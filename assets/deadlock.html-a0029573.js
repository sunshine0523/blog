import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as r,a as h}from"./app-2bc3c870.js";const d={},i=h('<h2 id="_1-死锁的四个条件" tabindex="-1"><a class="header-anchor" href="#_1-死锁的四个条件" aria-hidden="true">#</a> 1.死锁的四个条件</h2><ul><li>互斥：每个进程对于资源使用都是互斥不共享的</li><li><strong>不可剥夺</strong>：一个进程手中的资源，除非自己主动释放，其他进程不能剥夺</li><li>请求和保持：一个进程当前获得的资源不满足执行条件，它会继续请求资源，但是当前拥有的资源它不会释放</li><li>循环等待：存在这样一个队列，队列中的进程A需要进程B手中的资源，进程B又需要进程A手中的资源</li></ul><p>只有这四个条件同时成立，才会发生死锁，所以，只要让其中一个条件不成立，就可以解除死锁</p><h2 id="_2-死锁预防" tabindex="-1"><a class="header-anchor" href="#_2-死锁预防" aria-hidden="true">#</a> 2.死锁预防</h2><p>死锁预防感觉更像是悲观锁的方式，就是在运行之前就认为可能会发生死锁，所以采用一些方式预防。</p><p>上面我们说，只要死锁的四个条件有一个不满足，那么就不会有死锁了。我们可以考虑破坏死锁的四个条件之一。</p><h3 id="_2-1-破坏互斥" tabindex="-1"><a class="header-anchor" href="#_2-1-破坏互斥" aria-hidden="true">#</a> 2.1 破坏互斥</h3><p>让资源不是互斥的访问，这对一些只读文件什么的还是可以的，但是对于大部分共享资源可能不是那么适用</p><h3 id="_2-2-破坏不可剥夺" tabindex="-1"><a class="header-anchor" href="#_2-2-破坏不可剥夺" aria-hidden="true">#</a> 2.2 破坏不可剥夺</h3><p>如果一个进程在等待过程中，可以把它手中的资源全部剥夺走，给其他进程使用</p><h3 id="_2-3-破坏请求保持" tabindex="-1"><a class="header-anchor" href="#_2-3-破坏请求保持" aria-hidden="true">#</a> 2.3 破坏请求保持</h3><p>一个进程在执行之前，可以获取所有资源，满足条件了再执行</p><h3 id="_2-4-破坏循环等待" tabindex="-1"><a class="header-anchor" href="#_2-4-破坏循环等待" aria-hidden="true">#</a> 2.4 破坏循环等待</h3><p>这个可以给资源编号，进程请求的资源必须按照资源编号顺序来进行，一个进程只有申请到了小号资源才能申请大号资源</p><h2 id="_3-死锁避免" tabindex="-1"><a class="header-anchor" href="#_3-死锁避免" aria-hidden="true">#</a> 3.死锁避免</h2><p>死锁避免更像是乐观锁的精神，它有一个安全状态和不安全状态，如果一个进程申请完资源变成了不安全状态，那么就拒绝分配。</p><p>所谓安全状态，就是指在当前分配的条件下，可以按照某种顺序，顺利的把所有进程都执行完。</p><p>银行家算法</p>',18),t=[i];function n(c,s){return e(),r("div",null,t)}const l=a(d,[["render",n],["__file","deadlock.html.vue"]]);export{l as default};
